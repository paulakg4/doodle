package de.bezier.tools;import processing.core.*;import java.util.regex.*;public class DParser{	final static public String TYPE_LINE = "line";	final static public String TYPE_BEZIER = "bezier";	final static public String TYPE_CURVE = "curve";	final static public String TYPE_RECT = "rect";	final static public String TYPE_ELLIPSE = "ellipse";		final static public String TYPE_BEGINSHAPE = "beginShape";	final static public String TYPE_VERTEX = "vertex";	final static public String TYPE_BEZIERVERTEX = "bezierVertex";	final static public String TYPE_CURVEVERTEX = "curveVertex";	final static public String TYPE_ENDSHAPE = "endShape";			static public boolean parseCode ( String codeIn, DParserListener listener )	{		Pattern p;		Matcher m;		String ps;				// --- remove single line comments				ps = "//.*";		p = Pattern.compile( ps, Pattern.CASE_INSENSITIVE );		m = p.matcher( codeIn );				codeIn = m.replaceAll("");				//System.out.println( codeIn );		//System.out.println( "------------------------------------------------------------------------------" );				// --- remove multi line comments				ps = "/\\*.*?\\*/";		p = Pattern.compile( ps, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL );		m = p.matcher( codeIn );				codeIn = m.replaceAll("");				//System.out.println( codeIn );		//System.out.println( "------------------------------------------------------------------------------" );				// --- remove line breaks, and other unneeded whitespace				ps = "[\\s]*";		p = Pattern.compile( ps, Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL );		m = p.matcher( codeIn );				codeIn = m.replaceAll("");				//System.out.println( codeIn );		//System.out.println( "------------------------------------------------------------------------------" );				// --- handle code blocks				ps = "(line[^a-z]*\\([^;]+|rect[^a-z]*\\([^;]+|ellipse[^a-z]*\\([^;]+|bezier[^a-z]*\\([^;]+|curve[^a-z]*\\([^;]+|beginShape.*?endShape[^;]+)";		p = Pattern.compile( ps, Pattern.CASE_INSENSITIVE );		m = p.matcher( codeIn );				while ( m.find() )		{			String block = codeIn.substring( m.start(), m.end() );			//System.out.println( block );			//System.out.println();			if ( block.indexOf( ';' ) == -1 )				parseBlock(block, listener);			else			{				String[] pieces = PApplet.split( block, ';' );				for ( int i = 0; i < pieces.length; i++ )				{					parseBlock(pieces[i], listener);				}			}		}				/*System.out.println( "------------------------------------------------------------------------------" );		System.out.println( codeIn );		System.out.println( "------------------------------------------------------------------------------" );*/				return true;	}			static private void parseBlock ( String block, DParserListener listener )	{		//System.out.println( block );				String ps = "([a-z]+)[\\s]*\\(([^)]*)\\)";		Pattern p = Pattern.compile(ps, Pattern.CASE_INSENSITIVE);		Matcher m = p.matcher( block );		if ( m.find() && m.groupCount() == 2 )		{			String type   = m.group(1);			float[] values;						if ( type.equals( TYPE_BEGINSHAPE ) )			{				int mode = PConstants.POLYGON;				String modeS = m.group(2).trim();								if ( modeS.equals("POINTS") )				{					mode = PConstants.POINTS;				}				else if ( modeS.equals("LINES") )				{					mode = PConstants.LINES;				}				else if ( modeS.equals("TRIANGLES") )				{					mode = PConstants.TRIANGLES;				}				else if ( modeS.equals("TRIANGLE_FAN") )				{					mode = PConstants.TRIANGLE_FAN;				}				else if ( modeS.equals("TRIANGLE_STRIP") )				{					mode = PConstants.TRIANGLE_STRIP;				}				else if ( modeS.equals("QUADS") )				{					mode = PConstants.QUADS;				}				else if ( modeS.equals("QUAD_STRIP") )				{					mode = PConstants.QUAD_STRIP;				}								/*				POINTS, LINES, TRIANGLES, TRIANGLE_FAN, TRIANGLE_STRIP, QUADS, QUAD_STRIP				*/								values = new float[]{ mode };			}			else if ( type.equals( TYPE_ENDSHAPE ) )			{				int mode = PConstants.OPEN;							if ( m.group(2).trim().equals( "CLOSE" ) )					mode = PConstants.CLOSE;								values = new float[]{ mode };			}			else				values = toValues(PApplet.split( m.group(2), ',' ));						/* TODO:			 *    - ensure enough values			 */						if ( values.length == 4 )			{				if ( type.equals(TYPE_LINE) )				{					//line( values[0], values[1], values[2], values[3] );				}				else if ( type.equals(TYPE_RECT) )				{					//rect( values[0], values[1], values[2], values[3] );				}				else if ( type.equals(TYPE_ELLIPSE) )				{					//ellipse( values[0], values[1], values[2], values[3] );				}				//listener.addShape( type, values );			}			else if ( values.length == 8 )			{				if ( type.equals(TYPE_BEZIER) )				{					//bezier( values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7] );				}				else if ( type.equals(TYPE_CURVE) )				{					//curve( values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7] );				}				//listener.addShape( type, values );			}						listener.addShape( type, values );		}		//System.out.println( "------------------------------------------------------------------------------" );	}		static private float[] toValues ( String[] vRaw )	{		float o[] = new float[vRaw.length];		for (int i = 0; i < vRaw.length; i++)		{		  try		  {			o[i] = new Float(vRaw[i]).floatValue();		  }		  catch (NumberFormatException e)		  {			e.printStackTrace();		  }		}   		return o;	}}